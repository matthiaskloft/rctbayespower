\nonstopmode{}
\documentclass[letterpaper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\makeatletter\@ifl@t@r\fmtversion{2018/04/01}{}{\usepackage[utf8]{inputenc}}\makeatother
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `rctbayespower'}}
\par\bigskip{\large \today}
\end{center}
\ifthenelse{\boolean{Rd@use@hyper}}{\hypersetup{pdftitle = {rctbayespower: Bayesian Power Analysis for Randomized Controlled Trials}}}{}
\ifthenelse{\boolean{Rd@use@hyper}}{\hypersetup{pdfauthor = {Matthias Kloft}}}{}
\begin{description}
\raggedright{}
\item[Title]\AsIs{Bayesian Power Analysis for Randomized Controlled Trials}
\item[Version]\AsIs{0.1.0}
\item[Description]\AsIs{Provides tools for conducting Bayesian power analysis for randomized controlled trials (RCTs) using 'brms' and Stan. The package enables simulation-based power analysis with flexible threshold-based decision criteria, estimation of power curves, and determination of optimal sample sizes. Supports continuous, binary, and count outcomes with custom model formulas, prior specifications, and parallel processing capabilities.}
\item[Author]\AsIs{Matthias Kloft [aut, cre, cph] (<}\url{https://orcid.org/0000-0003-1845-6957}\AsIs{>)}
\item[Maintainer]\AsIs{Matthias Kloft }\email{kloft.dev+rctbayespower@gmail.com}\AsIs{}
\item[License]\AsIs{GPL-3}
\item[Encoding]\AsIs{UTF-8}
\item[Roxygen]\AsIs{list(markdown = TRUE)}
\item[RoxygenNote]\AsIs{7.3.2}
\item[Depends]\AsIs{R (>= 4.1.0)}
\item[Imports]\AsIs{brms (>= 2.20.0),
posterior,
ggplot2,
dplyr,
tidyr,
tibble,
parallel,
scales,
rlang}
\item[Suggests]\AsIs{testthat (>= 3.0.0),
knitr,
rmarkdown,
covr}
\item[Config/testthat/edition]\AsIs{3}
\item[VignetteBuilder]\AsIs{knitr}
\end{description}
\Rdcontents{Contents}
\HeaderA{rctbayespower-package}{The 'rctbayespower' package.}{rctbayespower.Rdash.package}
\aliasA{rctbayespower}{rctbayespower-package}{rctbayespower}
\keyword{internal}{rctbayespower-package}
%
\begin{Description}
Bayesian power analysis for randomized controlled trials (RCTs) using brms and Stan.
Provides tools for estimating power curves, determining optimal sample sizes, and
incorporating prior knowledge about treatment effects using region of practical
equivalence (ROPE) for decision making.
\end{Description}
%
\begin{Section}{Main Functions}

\begin{description}

\item[\code{\LinkA{power\_analysis}{power.Rul.analysis}}] Flexible Bayesian power analysis with custom models and data generation
\item[\code{\LinkA{power\_analysis\_ancova}{power.Rul.analysis.Rul.ancova}}] Convenience wrapper for standard RCT designs with baseline covariates
\item[\code{\LinkA{power\_grid\_analysis}{power.Rul.grid.Rul.analysis}}] Comprehensive grid analysis varying sample sizes and effect sizes
\item[\code{\LinkA{validate\_power\_design}{validate.Rul.power.Rul.design}}] Pre-validation of analysis designs with model compilation
\item[\code{\LinkA{validate\_weighting\_function}{validate.Rul.weighting.Rul.function}}] Testing weighting function implementations
\item[\code{\LinkA{plot.rctbayespower\_grid}{plot.rctbayespower.Rul.grid}}] Visualization of power grid analysis results

\end{description}

\end{Section}
%
\begin{Section}{Key Features}

\begin{itemize}

\item{} Support for continuous, binary, and count outcomes
\item{} Model caching for improved performance in grid analyses
\item{} Design prior integration for weighted power computation
\item{} Comprehensive plotting system with multiple visualization options
\item{} Robust parallelization with proper parameter handling
\item{} ANCOVA models with baseline covariate support

\end{itemize}

\end{Section}
%
\begin{Author}
\strong{Maintainer}: Matthias Kloft \email{kloft.dev+rctbayespower@gmail.com} (\Rhref{https://orcid.org/0000-0003-1845-6957}{ORCID}) [copyright holder]

\end{Author}
\HeaderA{plot.rctbayespower}{Plot Power Analysis Results}{plot.rctbayespower}
%
\begin{Description}
Create visualizations for single power analysis results by converting them to
a grid format and using the existing grid plotting functionality.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'rctbayespower'
plot(x, type = "comparison", metric = "both", ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class 'rctbayespower' returned by power\_analysis()

\item[\code{type}] Type of plot to create. For single power analysis results, only
"comparison" is supported, showing power vs posterior probabilities

\item[\code{metric}] Which power metric to display:
\begin{itemize}

\item{} "success" - Success power and probability
\item{} "futility" - Futility power and probability
\item{} "both" - Both success and futility power and probabilities (default)

\end{itemize}


\item[\code{...}] Additional arguments (currently unused)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A ggplot2 object showing power analysis results
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# Create a mock power analysis result object
power_result <- structure(list(
  study_parameters = list(
    n_control = 100,
    n_treatment = 100,
    target_param = "grouptreat",
    threshold_success = 0.2,
    threshold_futility = 0,
    p_sig_success = 0.975,
    p_sig_futility = 0.5,
    target_power_success = 0.8,
    target_power_futility = 0.2
  ),
  power_success = 0.85,
  power_futility = 0.25,
  mean_prob_success = 0.82,
  mean_prob_futility = 0.23,
  convergence_rate = 0.95,
  n_simulations = 1000,
  successful_fits = 950,
  median_effect_estimate = 0.48,
  sd_median_effect_estimate = 0.12
), class = "rctbayespower")

# Create plot showing both success and futility metrics
plot(power_result)

# Show only success metrics
plot(power_result, metric = "success")

# Show only futility metrics  
plot(power_result, metric = "futility")

\end{ExampleCode}
\end{Examples}
\HeaderA{plot.rctbayespower\_grid}{Plot Power Grid Analysis Results}{plot.rctbayespower.Rul.grid}
%
\begin{Description}
Create comprehensive visualizations for power grid analysis results from power\_grid\_analysis().
Supports different plot types based on analysis type (sample\_only, effect\_only, or both varying).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'rctbayespower_grid'
plot(
  x,
  type = "auto",
  metric = "both",
  values = "both",
  show_target = TRUE,
  show_integrated = TRUE,
  facet_by = "effect_size",
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class 'rctbayespower\_grid' returned by power\_grid\_analysis()

\item[\code{type}] Type of plot to create:
\begin{itemize}

\item{} "auto" - Automatically detect best plot type based on analysis (default)
\item{} "power\_curve" - Power curve across single varying dimension
\item{} "heatmap" - 2D heatmap when both sample sizes and effect sizes vary
\item{} "integrated" - Integrated power results when design prior is used
\item{} "comparison" - Compare power vs posterior probabilities

\end{itemize}


\item[\code{metric}] Which power metric to display:
\begin{itemize}

\item{} "success" - Success power and probability
\item{} "futility" - Futility power and probability
\item{} "both" - Both success and futility power and probabilities (default)

\end{itemize}


\item[\code{values}] Which values to display:
\begin{itemize}

\item{} "both" - Both power and posterior probabilities (default)
\item{} "power" - Power only
\item{} "post\_prob" - Posterior probabilities only

\end{itemize}


\item[\code{show\_target}] Whether to show target power lines (default: TRUE)

\item[\code{show\_integrated}] Whether to include integrated power when available (default: TRUE)

\item[\code{facet\_by}] For power\_curve plots when both sample sizes and effect sizes vary:
\begin{itemize}

\item{} "effect\_size" - Facet by effect size, vary sample size on x-axis (default)
\item{} "sample\_size" - Facet by sample size, vary effect size on x-axis

\end{itemize}


\item[\code{...}] Additional arguments passed to ggplot2 functions
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A ggplot2 object
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# Sample size analysis plot
grid_result <- list(
  target_power_success = 0.9,
  target_power_futility = 0.95,
  threshold_success = 0.2,
  threshold_futility = 0,
  sample_sizes = c(100, 200),
  effect_sizes = 0.5,
  design_prior = NULL,
  analysis_type = "sample_only",
  power_surface = data.frame(
    n_total = c(100, 200),
    effect_size = c(0.5, 0.5),
    power_success = c(0.65, 0.85),
    power_futility = c(0.20, 0.15),
    mean_prob_success = c(0.72, 0.88),
    mean_prob_futility = c(0.25, 0.18)
  ),
  integrated_power = NULL,
  optimal_combinations = data.frame(),
  detailed_results = list()
)
class(grid_result) <- "rctbayespower_grid"
plot(grid_result) # Auto-detects power curve

# Effect size analysis plot
grid_result <- list(
  target_power_success = 0.9,
  target_power_futility = 0.95,
  threshold_success = 0.2,
  threshold_futility = 0,
  sample_sizes = 200,
  effect_sizes = c(0.4, 0.8),
  design_prior = NULL,
  analysis_type = "effect_only",
  power_surface = data.frame(
    n_total = c(200, 200),
    effect_size = c(0.4, 0.8),
    power_success = c(0.75, 0.92),
    power_futility = c(0.30, 0.08),
    mean_prob_success = c(0.78, 0.94),
    mean_prob_futility = c(0.32, 0.10)
  ),
  integrated_power = NULL,
  optimal_combinations = data.frame(),
  detailed_results = list()
)
class(grid_result) <- "rctbayespower_grid"
plot(grid_result) # Shows both success and futility, both power and probabilities

# Full grid heatmap
grid_result <- list(
  target_power_success = 0.9,
  target_power_futility = 0.95,
  threshold_success = 0.2,
  threshold_futility = 0,
  sample_sizes = c(100, 200),
  effect_sizes = c(0.4, 0.8),
  design_prior = NULL,
  analysis_type = "both",
  power_surface = data.frame(
    n_total = c(100, 200, 100, 200),
    effect_size = c(0.4, 0.4, 0.8, 0.8),
    power_success = c(0.60, 0.75, 0.80, 0.92),
    power_futility = c(0.35, 0.30, 0.15, 0.08),
    mean_prob_success = c(0.65, 0.78, 0.82, 0.94),
    mean_prob_futility = c(0.38, 0.32, 0.18, 0.10)
  ),
  integrated_power = NULL,
  optimal_combinations = data.frame(),
  detailed_results = list()
)
class(grid_result) <- "rctbayespower_grid"
plot(grid_result, type = "heatmap")

# Power curves faceted by effect size (when both vary)
plot(grid_result, type = "power_curve", facet_by = "effect_size")

# Power curves faceted by sample size (when both vary)
plot(grid_result, type = "power_curve", facet_by = "sample_size")

\end{ExampleCode}
\end{Examples}
\HeaderA{power\_analysis}{Flexible Bayesian Power Analysis for RCTs}{power.Rul.analysis}
%
\begin{Description}
Conduct Bayesian power analysis for randomized controlled trials using user-specified
models and data generation functions. This function uses a design-based approach with
separate models for true parameter specification and estimation.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
power_analysis(
  n_control,
  n_treatment,
  simulate_data_fn,
  model_formula_true_params = NULL,
  model_formula_estimation = NULL,
  family = NULL,
  priors_true_params = NULL,
  priors_estimation = NULL,
  target_param,
  threshold_success,
  threshold_futility,
  p_sig_success = 0.975,
  p_sig_futility = 0.5,
  n_simulations = 1000,
  brms_args = list(algorithm = "sampling", iter = 1500, warmup = 500, chains = 2, cores =
    1, init = 0.1, control = list(adapt_delta = 0.9)),
  seed = NULL,
  n_cores = 1,
  brms_design_true_params = NULL,
  brms_design_estimation = NULL,
  progress_updates = 10
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{n\_control}] Number of participants in control group

\item[\code{n\_treatment}] Number of participants in treatment group

\item[\code{simulate\_data\_fn}] User-defined function that takes (n\_control, n\_treatment) and returns a data frame

\item[\code{model\_formula\_true\_params}] brms formula object for design model with true parameters

\item[\code{model\_formula\_estimation}] brms formula object for estimation model

\item[\code{family}] Distributional family for brms (e.g., gaussian(), bernoulli(), poisson())

\item[\code{priors\_true\_params}] Priors with true parameter values (as constants) for design model

\item[\code{priors\_estimation}] Priors for estimation in power simulation

\item[\code{target\_param}] Name of the parameter to track for power calculation (without "b\_" prefix)

\item[\code{threshold\_success}] Upper threshold for success determination

\item[\code{threshold\_futility}] Lower threshold for futility determination (required)

\item[\code{p\_sig\_success}] Probability threshold for declaring success (default 0.975)

\item[\code{p\_sig\_futility}] Probability threshold for declaring futility (default 0.5)

\item[\code{n\_simulations}] Number of simulation iterations

\item[\code{brms\_args}] Arguments passed to brms for estimation models. Default includes algorithm="sampling", iter=1200, warmup=200, chains=2, cores=1. User can override any of these or add additional arguments.

\item[\code{seed}] Random seed for reproducibility

\item[\code{n\_cores}] Number of cores for parallel processing. If n\_cores > 1, simulations will run in parallel.

\item[\code{brms\_design\_true\_params}] Optional pre-fitted brms model with true parameters. If provided, this model will be used instead of fitting a new design model.

\item[\code{brms\_design\_estimation}] Optional pre-fitted brms model template for estimation. If provided, this model will be used instead of fitting a new design model.

\item[\code{progress\_updates}] Number of progress updates to show during parallel processing. Default is 10. Set to 0 to disable progress updates.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list containing power analysis results
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# Define data simulation function
simulate_data <- function(n_control, n_treatment) {
  data.frame(
    outcome = rnorm(n_control + n_treatment),
    baseline = rnorm(n_control + n_treatment),
    group = factor(rep(c(0, 1), times = c(n_control, n_treatment)),
      levels = c(0, 1), labels = c("ctrl", "treat")
    )
  )
}

# Define model formulas and priors
model_formula_true <- brms::bf(outcome ~ baseline + group, center = FALSE)
model_formula_est <- brms::bf(outcome ~ baseline + group)
priors_true <- c(
  brms::set_prior("constant(.2)", class = "b", coef = "baseline"),
  brms::set_prior("constant(.5)", class = "b", coef = "grouptreat"),
  brms::set_prior("constant(0)", class = "b", coef = "Intercept"),
  brms::set_prior("constant(1)", class = "sigma")
)
priors_est <- c(
  brms::set_prior("student_t(3, 0, 2)", class = "b"),
  brms::set_prior("student_t(3, 0, 1)", class = "b", coef = "baseline"),
  brms::set_prior("student_t(3, 0, 2)", class = "Intercept"),
  brms::set_prior("student_t(3, 0, 1)", class = "sigma")
)

# Run power analysis with optimized brms_args
power_result <- power_analysis(
  n_control = 100, 
  n_treatment = 100,
  simulate_data_fn = simulate_data,
  model_formula_true_params = model_formula_true,
  model_formula_estimation = model_formula_est,
  family = gaussian(),
  priors_true_params = priors_true,
  priors_estimation = priors_est,
  target_param = "grouptreat",
  threshold_success = 0.2,
  threshold_futility = 0,
  p_sig_success = 0.95,
  p_sig_futility = 0.8,
  n_simulations = 2,
  brms_args = list(algorithm = "meanfield"),
  n_cores = 1,
  progress_updates = 5
)

# Run power analysis with progress updates
power_result_custom <- power_analysis(
  n_control = 50, 
  n_treatment = 50,
  simulate_data_fn = simulate_data,
  model_formula_true_params = model_formula_true,
  model_formula_estimation = model_formula_est,
  family = gaussian(),
  priors_true_params = priors_true,
  priors_estimation = priors_est,
  target_param = "grouptreat",
  threshold_success = 0.2,
  threshold_futility = 0,
  p_sig_success = 0.95,
  p_sig_futility = 0.7,
  n_simulations = 2,
  brms_args = list(algorithm = "meanfield"),
  n_cores = 1,
  progress_updates = 5
)

# Alternative: Use pre-fitted models (e.g., from validate_power_design)
validation <- validate_power_design(
  n_control = 100, 
  n_treatment = 100,
  simulate_data_fn = simulate_data,
  model_formula_true_params = model_formula_true,
  model_formula_estimation = model_formula_est,
  family = gaussian(),
  priors_true_params = priors_true,
  priors_estimation = priors_est,
  target_param = "grouptreat"
)

power_result_prefitted <- power_analysis(
  n_control = 100, 
  n_treatment = 100,
  simulate_data_fn = simulate_data,
  target_param = "grouptreat",
  threshold_success = 0.2,
  threshold_futility = 0,
  p_sig_success = 0.95,
  p_sig_futility = 0.7,
  n_simulations = 1,
  brms_args = list(algorithm = "meanfield"),
  n_cores = 1,
  progress_updates = 5,
  brms_design_true_params = validation$brms_design_true_params,
  brms_design_estimation = validation$brms_design_estimation
)

\end{ExampleCode}
\end{Examples}
\HeaderA{power\_analysis\_ancova}{Power Analysis for ANCOVA Model (Multiple Outcome Types)}{power.Rul.analysis.Rul.ancova}
%
\begin{Description}
Convenience wrapper for power analysis using the ANCOVA model with baseline covariate.
This function automates the setup for a standard randomized controlled trial with
a baseline covariate following the exact template workflow. Supports continuous,
binary, and count outcomes.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
power_analysis_ancova(
  n_control,
  n_treatment,
  outcome_type = "continuous",
  effect_size,
  baseline_effect,
  intercept_value = 0,
  sigma_value = 1,
  threshold_success,
  threshold_futility,
  p_sig_success = 0.975,
  p_sig_futility = 0.5,
  n_simulations = 1000,
  priors_treatment = "student_t(3, 0, 2)",
  priors_baseline = "student_t(3, 0, 1)",
  priors_intercept = "student_t(3, 0, 2)",
  priors_sigma = "student_t(3, 0, 2)",
  brms_args = list(algorithm = "sampling", iter = 1500, warmup = 500, chains = 2, cores =
    1, init = 0.1, control = list(adapt_delta = 0.9)),
  seed = NULL,
  n_cores = 1,
  progress_updates = 10,
  compile_models_only = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{n\_control}] Number of participants in control group

\item[\code{n\_treatment}] Number of participants in treatment group

\item[\code{outcome\_type}] Type of outcome ("continuous", "binary", "count")

\item[\code{effect\_size}] True treatment effect (raw scale: continuous = raw difference, binary = log odds ratio, count = log rate ratio)

\item[\code{baseline\_effect}] True baseline covariate effect (raw scale)

\item[\code{intercept\_value}] True intercept value (raw scale)

\item[\code{sigma\_value}] True residual standard deviation (for continuous outcomes only)

\item[\code{threshold\_success}] Upper threshold for success determination

\item[\code{threshold\_futility}] Lower threshold for futility determination (required)

\item[\code{p\_sig\_success}] Probability threshold for declaring success (default 0.975)

\item[\code{p\_sig\_futility}] Probability threshold for declaring futility (default 0.5)

\item[\code{n\_simulations}] Number of simulation iterations

\item[\code{priors\_treatment}] Prior for treatment effect (default: student\_t(3, 0, 2))

\item[\code{priors\_baseline}] Prior for baseline effect (default: student\_t(3, 0, 1))

\item[\code{priors\_intercept}] Prior for intercept (default: student\_t(3, 0, 2))

\item[\code{priors\_sigma}] Prior for residual SD (default: student\_t(3, 0, 2), continuous only)

\item[\code{brms\_args}] Arguments passed to brms for model fitting. If empty, uses power\_analysis() defaults: algorithm="sampling", iter=1200, warmup=200, chains=2, cores=1. User can override any of these or add additional arguments.

\item[\code{seed}] Random seed for reproducibility

\item[\code{n\_cores}] Number of cores for parallel processing. If n\_cores > 1, simulations will run in parallel. Default is 1.

\item[\code{progress\_updates}] Number of progress updates to show during parallel processing. Default is 10. Set to 0 to disable progress updates.

\item[\code{compile\_models\_only}] If TRUE, only compile the brms models and return them without running simulations. Used for model caching in power\_grid\_analysis(). Default is FALSE.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list containing power analysis results, or if compile\_models\_only=TRUE, a list with compiled models and arguments for later use
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# Continuous outcome ANCOVA
power_result <- power_analysis_ancova(
  n_control = 100,
  n_treatment = 100,
  outcome_type = "continuous",
  effect_size = 0.5,
  baseline_effect = 0.2,
  threshold_success = 0.2,
  threshold_futility = 0,
  p_sig_success = 0.95,
  p_sig_futility = 0.8,
  n_simulations = 1,
  brms_args = list(algorithm = "meanfield"),
  n_cores = 1,
  progress_updates = 5
)

\end{ExampleCode}
\end{Examples}
\HeaderA{power\_grid\_analysis}{Power Grid Analysis for Bayesian RCTs}{power.Rul.grid.Rul.analysis}
%
\begin{Description}
Comprehensive analysis varying both sample sizes and effect sizes, with optional
design prior for integrated power computation. This function provides flexible
power analysis across multiple scenarios and can compute weighted average
power using user-specified prior distributions.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
power_grid_analysis(
  target_power_success = 0.9,
  target_power_futility = 0.95,
  sample_sizes,
  effect_sizes,
  threshold_success,
  threshold_futility,
  design_prior = NULL,
  percent_group_treat = 0.5,
  power_analysis_fn = "power_analysis",
  n_simulations = 500,
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{target\_power\_success}] Desired power level for success decisions (default: 0.9)

\item[\code{target\_power\_futility}] Desired power level for futility decisions (default: 0.95)

\item[\code{sample\_sizes}] Vector of total sample sizes to test

\item[\code{effect\_sizes}] Vector of effect sizes to test

\item[\code{threshold\_success}] Upper threshold for success determination (required)

\item[\code{threshold\_futility}] Lower threshold for futility determination (required)

\item[\code{design\_prior}] Optional design prior for the effect size for integrated power. Can be:
\begin{itemize}

\item{} A string in brms prior syntax (e.g., "normal(0.3, 0.1)", "student\_t(6, 0.5, 0.2)", "gamma(2, 3)", "beta(2, 5)", "exponential(1)", "uniform(0, 1)", etc.). Any distribution supported by brms with a corresponding density function is supported.
\item{} An R function taking effect size as input (e.g., function(x) dnorm(x, 0.5, 0.2))
\item{} NULL for no design prior (default)

\end{itemize}


\item[\code{percent\_group\_treat}] Percentage of total sample allocated to treatment group (default: .5)

\item[\code{power\_analysis\_fn}] Power analysis function to use. Either "power\_analysis" for custom models or "power\_analysis\_ancova" for ANCOVA wrapper (default: "power\_analysis")

\item[\code{n\_simulations}] Number of simulations per combination (default: 500)

\item[\code{...}] All arguments required by the chosen power analysis function (except n\_control, n\_treatment, effect\_size, threshold\_success, and threshold\_futility which are handled automatically)
\end{ldescription}
\end{Arguments}
%
\begin{Details}
This function runs power analyses across all combinations of sample\_sizes and effect\_sizes.
When design\_prior is provided, it computes integrated power by weighting each effect size
according to the specified design prior distribution.

The design prior can be specified in two ways:
\begin{itemize}

\item{} \strong{brms syntax}: String expressions like "normal(0.5, 0.2)" or "student\_t(6, 0.3, 0.1)"
\item{} \strong{R function}: User-defined function, e.g., function(x) dnorm(x, 0.5, 0.2)

\end{itemize}


For custom power analysis (power\_analysis\_fn = "power\_analysis"), you must provide:
simulate\_data\_fn, model\_formula\_true\_params, model\_formula\_estimation, family,
priors\_true\_params, priors\_estimation, target\_param

For ANCOVA power analysis (power\_analysis\_fn = "power\_analysis\_ancova"), you must provide:
outcome\_type, baseline\_effect
\end{Details}
%
\begin{Value}
A list of class "rctbayespower\_grid" containing:
\begin{itemize}

\item{} target\_power\_success: Desired success power level
\item{} target\_power\_futility: Desired futility power level
\item{} threshold\_success: Success threshold used in analysis
\item{} threshold\_futility: Futility threshold used in analysis
\item{} sample\_sizes: Vector of tested sample sizes
\item{} effect\_sizes: Vector of tested effect sizes
\item{} design\_prior: Design prior specification
\item{} power\_surface: Data frame with power results for all combinations
\item{} integrated\_power: If design prior provided, integrated power and probability across effect sizes
\item{} optimal\_combinations: Sample size/effect size combinations achieving target power
\item{} detailed\_results: Full power analysis results for each combination

\end{itemize}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# Basic analysis across sample sizes and effect sizes
grid_result <- power_grid_analysis(
  target_power_success = 0.8,
  sample_sizes = c(100, 200),
  effect_sizes = c(0.4, 0.8),
  threshold_success = 0.2,
  threshold_futility = 0,
  power_analysis_fn = "power_analysis_ancova",
  outcome_type = "continuous",
  baseline_effect = 0.2,
  n_simulations = 1,
  brms_args = list(algorithm = "meanfield"), # fast algorithm for testing
  n_cores = 1,
  progress_updates = 5
)

\end{ExampleCode}
\end{Examples}
\HeaderA{print.rctbayespower}{Print method for rctbayespower objects}{print.rctbayespower}
%
\begin{Description}
Print method for rctbayespower objects
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'rctbayespower'
print(x, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class "rctbayespower" returned by power\_analysis()

\item[\code{...}] Additional arguments (currently unused)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Invisibly returns the input object. Used for side effects (printing).
\end{Value}
\HeaderA{print.rctbayespower\_grid}{Print method for power grid analysis objects}{print.rctbayespower.Rul.grid}
%
\begin{Description}
Print method for power grid analysis objects
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'rctbayespower_grid'
print(x, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An rctbayespower\_grid object

\item[\code{...}] Additional arguments (unused)
\end{ldescription}
\end{Arguments}
\HeaderA{summary.rctbayespower}{Summary Method for Power Analysis Results}{summary.rctbayespower}
%
\begin{Description}
Provides a structured summary of Bayesian power analysis results.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'rctbayespower'
summary(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] An object of class "rctbayespower" returned by power\_analysis()

\item[\code{...}] Additional arguments (currently unused)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Invisibly returns the input object. Used for side effects (printing summary).
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Assuming you have a power analysis result
result <- power_analysis(...)
summary(result)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\HeaderA{summary.rctbayespower\_grid}{Summary method for power grid analysis objects}{summary.rctbayespower.Rul.grid}
%
\begin{Description}
Summary method for power grid analysis objects
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'rctbayespower_grid'
summary(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] An rctbayespower\_grid object

\item[\code{...}] Additional arguments (unused)
\end{ldescription}
\end{Arguments}
\HeaderA{validate\_power\_design}{Validate Power Analysis Design}{validate.Rul.power.Rul.design}
%
\begin{Description}
Helper function to validate the design components before running a full power analysis.
Performs a single simulation run and checks for convergence and parameter extraction.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
validate_power_design(
  n_control,
  n_treatment,
  simulate_data_fn,
  model_formula_true_params,
  model_formula_estimation,
  family,
  priors_true_params,
  priors_estimation,
  target_param,
  brms_args = list(algorithm = "sampling", iter = 1500, warmup = 500, chains = 2, cores =
    1, init = 0.1, control = list(adapt_delta = 0.9))
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{n\_control}] Number of participants in control group

\item[\code{n\_treatment}] Number of participants in treatment group

\item[\code{simulate\_data\_fn}] User-defined function that takes (n\_control, n\_treatment) and returns a data frame

\item[\code{model\_formula\_true\_params}] brms formula object for design model with true parameters

\item[\code{model\_formula\_estimation}] brms formula object for estimation model

\item[\code{family}] Distributional family for brms

\item[\code{priors\_true\_params}] Priors with true parameter values (as constants) for design model

\item[\code{priors\_estimation}] Priors for estimation in power simulation

\item[\code{target\_param}] Name of the parameter to track for power calculation (without "b\_" prefix)

\item[\code{brms\_args}] Arguments passed to brms for validation runs. Default includes algorithm="sampling", iter=700, warmup=200, chains=2, cores=1. User can override any of these or add additional arguments.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list containing validation results, model summaries, and compiled design models (brms\_design\_true\_params and brms\_design\_estimation) that can be reused in power\_analysis()
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Validate design before running full power analysis
validation <- validate_power_design(
  n_control = 50, 
  n_treatment = 50,
  simulate_data_fn = simulate_data,
  model_formula_true_params = model_formula_true,
  model_formula_estimation = model_formula_est,
  family = gaussian(),
  priors_true_params = priors_true,
  priors_estimation = priors_est,
  target_param = "grouptreat"
)

# Use the compiled models from validation in power analysis
power_result <- power_analysis(
  n_control = 50, 
  n_treatment = 50,
  simulate_data_fn = simulate_data,
  target_param = "grouptreat",
  threshold_success = 0.2,
  threshold_futility = 0,
  p_sig_success = 0.95,
  p_sig_futility = 0.5,
  n_simulations = 2,
  brms_design_true_params = validation$brms_design_true_params,
  brms_design_estimation = validation$brms_design_estimation
  brms_args = list(algorithm = "meanfield"),
  n_cores = 1,
  progress_updates = 5
)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\HeaderA{validate\_weighting\_function}{Validate Weighting Function Implementation}{validate.Rul.weighting.Rul.function}
%
\begin{Description}
Tests that the weighting function parsing and computation in power\_grid\_analysis()
works correctly. This function validates both brms syntax parsing and R function handling,
as well as the weighted power computation logic.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
validate_weighting_function(effect_sizes = seq(0.2, 0.8, 0.1), verbose = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{effect\_sizes}] Vector of effect sizes to test with (default: seq(0.2, 0.8, 0.1))

\item[\code{verbose}] Whether to print detailed test results (default: TRUE)
\end{ldescription}
\end{Arguments}
%
\begin{Details}
This validation function tests:
\begin{itemize}

\item{} Normal distribution parsing from brms syntax
\item{} Student-t distribution parsing from brms syntax
\item{} Custom R function validation
\item{} Weight normalization (ensures weights sum to 1)
\item{} Quantile computation for coverage checking
\item{} Error handling for invalid inputs

\end{itemize}

\end{Details}
%
\begin{Value}
A list containing validation results:
\begin{itemize}

\item{} all\_tests\_passed: Boolean indicating if all tests passed
\item{} test\_results: List of individual test results
\item{} errors: Any errors encountered during testing

\end{itemize}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Run validation with default settings
validation_results <- validate_weighting_function()

# Run validation quietly
validation_results <- validate_weighting_function(verbose = FALSE)

# Check if all tests passed
if (validation_results$all_tests_passed) {
  message("All weighting function tests passed!")
} else {
  message("Some tests failed. Check validation_results$test_results for details.")
}

## End(Not run)
\end{ExampleCode}
\end{Examples}
\printindex{}
\end{document}
