---
title: "Getting Started with rctbayespower: Bayesian Power Analysis for RCTs"
date: "`r Sys.Date()`"
always_allow_html: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "vignettes/man/figures/03-algorithm_performance-",
  out.width = "90%",
  fig.width = 10,
  fig.height = 7,
  message = FALSE
)

# Set CRAN mirror
options(repos = c(CRAN = "https://cloud.r-project.org/"))

# Check and install required packages
packages <- c("tidyverse", "devtools")
install.packages(setdiff(packages, rownames(installed.packages())))
invisible(lapply(packages, require, character.only = TRUE))

# Load the package
devtools::load_all(".")

# Fast performance testing settings
n_cores <- parallel::detectCores() - 1
n_sims <- 1e3
```



# Algorithm Performance and Computational Considerations

This vignette provides guidance on algorithm selection, performance optimization, and computational considerations when using the `rctbayespower` package for Bayesian power analysis.


## Algorithm Overview

The `rctbayespower` package supports multiple algorithms with different speed-accuracy trade-offs:

**Recommended workflow:**
1. **Exploration**: `meanfield` for faster roundtrip
2. **Refinement**: `fullrank` as an alternative to `meanfield` for more accuracy, however might not converge
3. **Confirmation**: `sampling` for final results



# Performance Comparison

## Setup
### Model

```{r}
model_file <- here::here("test_model_ancova.rds")
if (file.exists(model_file)) {
  # load the model from a file
  model_ancova <- readRDS(model_file)
} else{
  # create the model
  model_ancova <- build_model_ancova_cont()
  # save the model to a file
  saveRDS(model_ancova, file = model_file)
}
print(model_ancova)
```

### Design

```{r}
design <- build_design(
  model = model_ancova,
  target_params = "b_armtreat",
  thresholds_success = 0.1,
  thresholds_futility = 0,
  p_sig_success = 0.975,
  p_sig_futility = 0.5
)
# check the required parameters for the design
required_parameters(design)

```


### Conditions

```{r}
conditions <- build_conditions(
  design = design,
  condition_values = list(
    # two sample sizes
    n_total = 300,
        # two effect sizes
    b_armtreat = c(0,0.3)
  ),
  static_values = list(
    # equal allocation
    p_alloc =
      list(c(0.5, 0.5)),
          # baseline effect
    b_baseline = 0
  )
)
print(conditions, n = 100)
```


## Run Simulations for Comparison

```{r basic_performance}
n_cores <- parallel::detectCores() - 2
n_sims <- n_cores * 40

# Meanfield
suppressWarnings(
  power_result_meanfield <-
    power_grid_analysis(
      conditions = conditions,
      n_cores = n_cores,
      n_simulations = n_sims,
      verbose = FALSE,
      brms_args = list(
        algorithm = "meanfield",
        importance_resampling = TRUE,
        iter = 1e4,
        output_samples = 2e3
      )
    )
)

# Meanfield
suppressWarnings(
  power_result_fullrank <-
    power_grid_analysis(
      conditions = conditions,
      n_cores = n_cores,
      n_simulations = n_sims,
      verbose = FALSE,
      brms_args = list(
        algorithm = "fullrank",
        importance_resampling = TRUE,
        iter = 1e4,
        output_samples = 2e3
      )
    )
)

# Sampling
power_result_sampling <- power_grid_analysis(
  conditions = conditions,
  n_cores = n_cores,
  n_simulations = n_sims,
  verbose = FALSE,
  brms_args = list(
    chains = 4,
    iter = 700,
    warmup = 200
  )
)

results_summary<- rbind(
  power_result_meanfield$results_df,
  power_result_fullrank$results_df,
  power_result_sampling$results_df
)

# Print results table
print(kableExtra::kable(results_summary, digits = 2))
print(results_summary, digits = 2)
```



***


# Session Information

```{r session_info}
sessionInfo()
```
