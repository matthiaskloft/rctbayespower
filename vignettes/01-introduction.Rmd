---
title: "Getting Started with rctbayespower: Bayesian Power Analysis for RCTs"
date: "2025-07-22"
always_allow_html: true
---

# Introduction

The `rctbayespower` package provides tools for conducting Bayesian power
analysis for randomized controlled trials (RCTs) using the `brms`
package and Stan. Unlike traditional frequentist power analysis,
Bayesian power analysis allows researchers to:

- Incorporate prior knowledge about treatment effects
- Use probabilistic statements about effect sizes
- Consider regions of practical equivalence (ROPE)
- Account for uncertainty in parameter estimates

This vignette demonstrates the main functions of the package with
practical examples using real model fitting.

# Basic Power Analysis Using ANCOVA Design

### Model

``` r
model_file <- here::here("test_model_ancova.rds")
if (file.exists(model_file)) {
  # load the model from a file
  model_ancova <- readRDS(model_file)
} else{
  # create the model
  model_ancova <- build_model(pre_defined_model = "ancova_cont_2arms")
  # save the model to a file
  saveRDS(model_ancova, file = model_file)
}
print(model_ancova)
#> 
#> Object of class: 'rctbayespower_model'
#> --------------------------------------------------
#> 
#> Model name: 
#> Number of endpoints: 
#> Endpoint types:  
#> Number of arms: 
#> Number of repeated measures: 0 
#> Parameter names - simulation function: n_total n_arms contrasts p_alloc intercept b_arms_treat b_covariate sigma 
#> Parameter names - brms model: b_Intercept b_covariate b_arm2 
#> Arguments to specify for simulation function:
#> [1] "n_total"      "b_arms_treat" "b_covariate" 
#> 
#> Brms model:
#>  Family: gaussian 
#>   Links: mu = identity; sigma = identity 
#> Formula: outcome ~ 1 + covariate + arm 
#>    Data: mock_data_ancova (Number of observations: 20) 
#> 
#> The model does not contain posterior draws.
```

### Design

Find possible target parameters in the model.

``` r
attr(model_ancova, "parameter_names_brms")
#> NULL
```

Specify the study design with target parameter, thresholds for success
and futility, and significance levels for frequentist-like power.

``` r
design <- build_design(
  model = model_ancova,
  target_params = "b_arm2",
  thresholds_success = 0.1,
  thresholds_futility = 0,
  p_sig_success = 0.975,
  p_sig_futility = 0.5
)
print(design)
#> 
#> Object of class: 'rctbayespower_design'
#> --------------------------------------------------
#> 
#> === Model Specifications ===
#> 
#> Number of endpoints: 1 
#> Endpoint types: continuous 
#> Number of arms: 2 
#> Number of repeated measures: 0 
#> Parameter names - simulation function: n_total, n_arms, contrasts, p_alloc, intercept, b_arms_treat, b_covariate, sigma 
#> Parameter names - brms model: b_Intercept, b_covariate, b_arm2 
#> 
#> 
#> === Design Specifications ===
#> 
#> Design name: 
#> Target parameters: b_arm2 
#> Number of interim analyses: 
#> Thresholds for success: 0.1 
#> Thresholds for futility: 0 
#> Probability of success significance: 0.975 
#> Probability of futility significance: 0.5 
#> Parameter names - interim function:  
#> 
#> 
#> === Data Simulation Function ===
#> 
#> function(n_total,
#>              n_arms = default_n_arms,
#>              contrasts = default_contrasts,
#>              p_alloc = default_p_alloc,
#>              intercept = default_intercept,
#>              b_arms_treat = default_b_arms_treat,
#>              b_covariate = default_b_covariate,
#>              sigma = default_sigma) {
#>       # validation of inputs -----------------------------------------------------
#> 
#>       # validate n_total, must be numeric and whole number
#>       if (is.null(n_total) ||
#>           !is.numeric(n_total) || length(n_total) != 1 ||
#>           n_total <= 0 || n_total != round(n_total)) {
#>         stop("'n_total' must be a positive integer value.")
#>       }
#>       # validate n_arms, must be integer > 2
#>       if (is.null(n_arms) ||
#>           !is.numeric(n_arms) || length(n_arms) != 1 ||
#>           n_arms < 2 || n_arms != round(n_arms)) {
#>         stop("'n_arms' must be a positive integer greater than or equal to 2.")
#>       }
#>       # validate contrasts, must be a string or matrix for creating contrasts
#>       if (!is.null(contrasts) &
#>           !is.character(contrasts) & !is.matrix(contrasts)) {
#>         stop(
#>           "'contrasts' must be a character string indicating a contrast method (e.g., \"contr.treatment\") or a matrix."
#>         )
#>       } else{
#>         # create contrast matrix
#>         if (!is.null(contrasts) & is.character(contrasts)) {
#>           # validate string is one of the valid 'contr.' methods from 'stats'
#>           valid_contrasts <- c(
#>             "contr.treatment",
#>             "contr.sum",
#>             "contr.poly",
#>             "contr.helmert",
#>             "contr.SAS"
#>           )
#>           if (!(contrasts %in% valid_contrasts)) {
#>             stop(
#>               paste0(
#>                 "'contrasts' must be one of the following valid contrast methods: ",
#>                 paste(valid_contrasts, collapse = ", ")
#>               )
#>             )
#>           }
#>           # create contrast matrix
#>           tryCatch({
#>             contrasts_fn <- get(contrasts)
#>             contrast_matrix <- contrasts_fn(n_arms)
#>           }, error = function(e) {
#>             stop("'contrasts' must be a valid contrast method (e.g., \"contr.treatment\").")
#>           })
#>         }
#>       }
#>       # validate matrix
#>       if (!is.null(contrasts) & is.matrix(contrasts)) {
#>         # validate dimensions of contrast matrix,
#>         # nrow == n_arms, ncol == n_arms - 1
#>         if (nrow(contrasts) != n_arms ||
#>             ncol(contrasts) != n_arms - 1) {
#>           stop("'contrasts' matrix must have dimensions n_arms x (n_arms - 1).")
#>         }
#>         tryCatch({
#>           contrasts_fn <- get(contrasts)
#>           contrast_matrix <- contrasts
#>         }, error = function(e) {
#>           stop(
#>             "'contrasts' must be a valid contrast method (e.g., \"contr.treatment\") or matrix."
#>           )
#>         })
#>       }
#>       # validate p_alloc, must be of length n_arms
#>       # must be a numeric vector of probabilities summing to 1
#>       if (is.null(p_alloc) ||
#>           !is.numeric(p_alloc) || length(p_alloc) != n_arms ||
#>           sum(p_alloc) != 1) {
#>         stop("'p_alloc' must be a numeric vector of probabilities summing to 1.")
#>       }
#>       # validate intercept, must be numeric
#>       if (is.null(intercept) || !is.numeric(intercept)) {
#>         stop("'intercept' must be a numeric value.")
#>       }
#>       # validate b_arms_treat, must be numeric
#>       if (is.null(b_arms_treat) || !is.numeric(b_arms_treat)) {
#>         stop("'b_arms_treat' must be a numeric value.")
#>       }
#>       # validate b_covariate, must be numeric
#>       if (is.null(b_covariate) || !is.numeric(b_covariate)) {
#>         stop("'b_covariate' must be a numeric value.")
#>       }
#>       # validate sigma, must be numeric and positive
#>       if (is.null(sigma) || !is.numeric(sigma) || sigma <= 0) {
#>         stop("'sigma' must be a positive numeric value.")
#>       }
#> 
#>       # end of validation --------------------------------------------------------
#> 
#> 
#>       # simulate data for ANCOVA -------------------------------------------------
#> 
#>       # predictors
#>       df <- data.frame(
#>         covariate = stats::rnorm(n_total),
#>         arm = factor(
#>           sample(
#>             x = seq_len(n_arms) - 1,
#>             size = n_total,
#>             prob = p_alloc,
#>             replace = TRUE
#>           ),
#>           levels = seq_len(n_arms) - 1,
#>           labels = c("ctrl", paste0("treat_", seq_len(n_arms - 1)))
#>         )
#>       )
#>       # set contrasts
#>       contrasts(df$arm) <- contrast_matrix
#> 
#>       # simulate outcomes
#>       df <- df |>
#>         dplyr::mutate(
#>           # outcome
#>           outcome = stats::rnorm(
#>             n_total,
#>             mean = intercept +
#>               model.matrix( ~ arm, data = df)[, -1, drop = FALSE] %*% b_arms_treat +
#>               covariate * b_covariate,
#>             sd = sigma
#>           )
#>         )
#>       return(df)
#>     }
#> <environment: 0x000001bb41d92a88>
#> 
#> 
#> === Brms Model ===
#> 
#>  Family: gaussian 
#>   Links: mu = identity; sigma = identity 
#> Formula: outcome ~ 1 + covariate + arm 
#>    Data: mock_data_ancova (Number of observations: 20) 
#> 
#> The model does not contain posterior draws.
#> 
#> 
#>  === Allocation Function ===
#> 
#> NULL
```

### Conditions

Find parameters that need user specification for the design.

``` r
required_fn_args(design)
#> 
#> Arguments that need user specification.
#> 
#> Simulation function:
#> n_total, b_arms_treat, b_covariate 
#> 
#> Interim function:
#> 
```

Specify conditions.

``` r
conditions <- build_conditions(
  design = design,
  condition_values = list(
    # two sample sizes
    n_total = 300,
        # two effect sizes
    b_arms_treat = c(0,0.3)
  ),
  static_values = list(
    # equal allocation
    p_alloc =
      list(c(0.5, 0.5)),
          # baseline effect
    b_covariate = 0
  )
)
print(conditions, n = 100)
#> 
#> Object of class: 'rctbayespower_conditions'
#> --------------------------------------------------
#> 
#> Number of conditions: 2 
#> Number of varying parameters: 3 
#> 
#> Condition Grid:
#> # A tibble: 2 × 3
#>   id_cond n_total b_arms_treat
#>     <int>   <dbl>        <dbl>
#> 1       1     300          0  
#> 2       2     300          0.3
```

## Run Power Analysis

Set number of cores and simulations. The number of simulations is set to
a lower value for faster vignette building, but you can increase it for
more robust results.

``` r
n_cores <- parallel::detectCores() - 2
n_sims <- n_cores * 30
```

``` r
power_results <- power_analysis(
  conditions = conditions,
  n_cores = n_cores,
  n_simulations = n_sims,
  verbose = FALSE,
  brms_args = list(
    chains = 4,
    iter = 700,
    warmup = 200
  )
)

power_results$results_df
#> # A tibble: 2 × 30
#>   id_cond n_total b_arms_treat parameter    threshold_success threshold_futility
#>     <dbl>   <dbl>        <dbl> <named list>             <dbl>              <dbl>
#> 1       1     300          0   <chr [1]>                  0.1                  0
#> 2       2     300          0.3 <chr [1]>                  0.1                  0
#> # ℹ 24 more variables: success_prob <dbl>, success_prob_mcse <dbl>,
#> #   futility_prob <dbl>, futility_prob_mcse <dbl>, success_power <dbl>,
#> #   success_power_mcse <dbl>, futility_power <dbl>, futility_power_mcse <dbl>,
#> #   est_median <dbl>, est_median_mcse <dbl>, est_mad <dbl>, est_mad_mcse <dbl>,
#> #   est_mean <dbl>, est_mean_mcse <dbl>, est_sd <dbl>, est_sd_mcse <dbl>,
#> #   rhat <dbl>, rhat_mcse <dbl>, ess_bulk <dbl>, ess_bulk_mcse <dbl>,
#> #   ess_tail <dbl>, ess_tail_mcse <dbl>, convergence_rate <dbl>, …
```

------------------------------------------------------------------------

# Session Information

``` r
sessionInfo()
#> R version 4.5.0 (2025-04-11 ucrt)
#> Platform: x86_64-w64-mingw32/x64
#> Running under: Windows 11 x64 (build 26100)
#> 
#> Matrix products: default
#>   LAPACK version 3.12.1
#> 
#> locale:
#> [1] LC_COLLATE=German_Germany.utf8  LC_CTYPE=German_Germany.utf8   
#> [3] LC_MONETARY=German_Germany.utf8 LC_NUMERIC=C                   
#> [5] LC_TIME=German_Germany.utf8    
#> 
#> time zone: Europe/Berlin
#> tzcode source: internal
#> 
#> attached base packages:
#> [1] stats     graphics  grDevices utils     datasets  methods   base     
#> 
#> other attached packages:
#>  [1] rctbayespower_0.1.0 testthat_3.2.3      devtools_2.4.5     
#>  [4] usethis_3.1.0       lubridate_1.9.4     forcats_1.0.0      
#>  [7] stringr_1.5.1       dplyr_1.1.4         purrr_1.0.4        
#> [10] readr_2.1.5         tidyr_1.3.1         tibble_3.3.0       
#> [13] ggplot2_3.5.2       tidyverse_2.0.0     here_1.0.1         
#> [16] rmarkdown_2.29     
#> 
#> loaded via a namespace (and not attached):
#>  [1] tidyselect_1.2.1     farver_2.1.2         loo_2.8.0           
#>  [4] fastmap_1.2.0        tensorA_0.36.2.1     promises_1.3.3      
#>  [7] digest_0.6.37        timechange_0.3.0     mime_0.13           
#> [10] lifecycle_1.0.4      StanHeaders_2.32.10  ellipsis_0.3.2      
#> [13] magrittr_2.0.3       posterior_1.6.1      compiler_4.5.0      
#> [16] rlang_1.1.6          tools_4.5.0          yaml_2.3.10         
#> [19] knitr_1.50           bridgesampling_1.1-2 htmlwidgets_1.6.4   
#> [22] pkgbuild_1.4.8       RColorBrewer_1.1-3   pkgload_1.4.0       
#> [25] abind_1.4-8          miniUI_0.1.2         withr_3.0.2         
#> [28] desc_1.4.3           stats4_4.5.0         grid_4.5.0          
#> [31] urlchecker_1.0.1     profvis_0.4.0        colorspace_2.1-1    
#> [34] inline_0.3.21        xtable_1.8-4         scales_1.4.0        
#> [37] cli_3.6.5            mvtnorm_1.3-3        generics_0.1.4      
#> [40] remotes_2.5.0        RcppParallel_5.1.10  rstudioapi_0.17.1   
#> [43] tzdb_0.5.0           sessioninfo_1.2.3    cachem_1.1.0        
#> [46] rstan_2.32.7         bayesplot_1.13.0     parallel_4.5.0      
#> [49] matrixStats_1.5.0    brms_2.22.0          vctrs_0.6.5         
#> [52] Matrix_1.7-3         hms_1.1.3            glue_1.8.0          
#> [55] codetools_0.2-20     distributional_0.5.0 stringi_1.8.7       
#> [58] gtable_0.3.6         QuickJSR_1.8.0       later_1.4.2         
#> [61] pillar_1.11.0        htmltools_0.5.8.1    Brobdingnag_1.2-9   
#> [64] brio_1.1.5           R6_2.6.1             rprojroot_2.0.4     
#> [67] evaluate_1.0.4       shiny_1.11.0         lattice_0.22-7      
#> [70] backports_1.5.0      memoise_2.0.1        httpuv_1.6.16       
#> [73] rstantools_2.4.0     Rcpp_1.0.14          gridExtra_2.3       
#> [76] coda_0.19-4.1        nlme_3.1-168         checkmate_2.3.2     
#> [79] xfun_0.52            fs_1.6.6             pkgconfig_2.0.3
```
