% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/power_analysis.R
\name{power_analysis}
\alias{power_analysis}
\title{Power Analysis for Bayesian RCTs (New API)}
\usage{
power_analysis(
  conditions,
  design_prior = NULL,
  n_simulations = 500,
  n_cores = 1,
  n_progress_updates = 10,
  verbose = FALSE,
  brms_args = list(),
  ...
)
}
\arguments{
\item{conditions}{A conditions object created by \code{\link[=build_conditions]{build_conditions()}} containing:
\itemize{
\item design: An rctbayespower_design object with model specifications
\item condition_arguments: List of prepared condition arguments for simulation
}}

\item{design_prior}{Optional design prior for integrated power computation. Can be:
\itemize{
\item A string in brms prior syntax (e.g., "normal(0.3, 0.1)", "student_t(6, 0.5, 0.2)")
\item An R function taking effect size as input (e.g., function(x) dnorm(x, 0.5, 0.2))
\item NULL for no design prior (default)
}}

\item{n_simulations}{Number of MCMC iterations per condition (default: 500)}

\item{n_cores}{Number of parallel cores for condition execution (default: 1)}

\item{n_progress_updates}{Show progress every N conditions when running sequentially (default: 10)}

\item{verbose}{Logical. Whether to show detailed progress information (default: FALSE)}

\item{brms_args}{Arguments passed to brms for model fitting. Default includes 'algorithm' = "sampling", 'iter' = 500, 'warmup' = 250, 'chains' = 4, 'cores' = 1. User can override any of these or add additional arguments.}

\item{...}{Additional arguments passed to brms for model fitting. These have the highest priority and will override both defaults and 'brms_args'.}
}
\value{
A list of class "rctbayespower_sim_result" containing:
\itemize{
\item design: The design object used for analysis
\item conditions: The condition specifications used
\item target_power_success: Target power level for success
\item target_power_futility: Target power level for futility
\item power_surface: Data frame with power results for all conditions
\item optimal_combinations_success: Conditions achieving target success power
\item optimal_combinations_futility: Conditions achieving target futility power
\item sample_sizes: Unique sample sizes tested
\item unique_effect_combinations: Unique effect size combinations tested
\item detailed_results: Full simulation results for each condition
}
}
\description{
Comprehensive power analysis across multiple conditions using the new object-oriented
API. This function provides flexible power analysis by varying sample sizes, effect
sizes, interim analyses, and other parameters across a grid of conditions.
}
\details{
This implementation is optimized for performance through:
\itemize{
\item Direct index-based parallel execution (no intermediate data structures)
\item Efficient data combination using dplyr::bind_rows
\item Minimal console output (controlled by verbose parameter)
\item Simplified cluster setup without OS detection overhead
}

This modernized function uses the new object-oriented API and provides several advantages:

\strong{Unified Parameter Management:} All model and analysis specifications are contained
in the rctbayespower_design object, ensuring consistency and reducing parameter errors.

\strong{Flexible Condition Specification:} Conditions can vary any combination of sample sizes,
effect sizes, interim analyses, allocation ratios, and other parameters independently.

\strong{Full Parallelization:} All conditions are executed in parallel when n_cores > 1,
maximizing computational efficiency across the entire parameter grid.

\strong{Named Effect Sizes:} Effect sizes must be specified as named lists matching the
target_params from the design object, enabling multi-parameter analysis.

\strong{Extensible Design:} Easy to add new condition parameters (e.g., interim analyses)
without changing the function signature.
}
\examples{
\dontrun{
# Create an ANCOVA model and design
ancova_model <- build_model("ancova_cont_2arms")()
design <- build_design(
  build_model = ancova_model,
  target_params = "b_arms_treat",
  n_interim_analyses = 0,
  thresholds_success = 0.2,
  thresholds_futility = 0.0,
  p_sig_success = 0.975,
  p_sig_futility = 0.5
)

# Create conditions grid
conditions <- expand_conditions(
  sample_sizes = c(100),
  b_arms_treat = c(0.5),
)

# Run power analysis
result <- power_analysis(
  conditions = conditions,
  n_simulations = 10, # Low for example
  n_cores = 1
)
}
}
