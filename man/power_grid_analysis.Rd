% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/power_grid_analysis.R
\name{power_grid_analysis}
\alias{power_grid_analysis}
\title{Power Grid Analysis for Bayesian RCTs (New API)}
\usage{
power_grid_analysis(
  design,
  conditions,
  static_parameters = list(),
  design_prior = NULL,
  n_simulations = 500,
  n_cores = parallel::detectCores() - 1,
  progress_updates = 10,
  ...
)
}
\arguments{
\item{design}{An rctbayespower_design object containing the model
specifications, target parameters, thresholds, and analysis configuration}

\item{conditions}{List of condition specifications. Each condition must include:
\itemize{
\item n_total: Total sample size for this condition
\item effect_sizes: Named list of effect sizes matching target_params from design
\item n_interim_analyses: Number of interim analyses (optional, defaults to design value)
\item p_alloc: Treatment allocation probabilities (optional, defaults to c(0.5, 0.5))
\item true_parameter_values: Additional simulation parameters (optional)
}}

\item{static_parameters}{List of parameters that override design defaults across all conditions.
Can include: target_power_success, target_power_futility, true_parameter_values, etc.}

\item{design_prior}{Optional design prior for integrated power computation. Can be:
\itemize{
\item A string in brms prior syntax (e.g., "normal(0.3, 0.1)", "student_t(6, 0.5, 0.2)")
\item An R function taking effect size as input (e.g., function(x) dnorm(x, 0.5, 0.2))
\item NULL for no design prior (default)
}}

\item{n_simulations}{Number of MCMC iterations per condition (default: 500)}

\item{n_cores}{Number of parallel cores for condition execution (default: detectCores() - 1)}

\item{progress_updates}{Show progress every N conditions when running sequentially (default: 10)}

\item{...}{Additional arguments passed to brms fitting (e.g., algorithm, chains)}
}
\value{
A list of class "rctbayespower_grid" containing:
\itemize{
\item design: The design object used for analysis
\item conditions: The condition specifications used
\item static_parameters: Static parameter overrides applied
\item target_power_success: Target power level for success
\item target_power_futility: Target power level for futility
\item power_surface: Data frame with power results for all conditions
\item optimal_combinations_success: Conditions achieving target success power
\item optimal_combinations_futility: Conditions achieving target futility power
\item sample_sizes: Unique sample sizes tested
\item unique_effect_combinations: Unique effect size combinations tested
\item detailed_results: Full simulation results for each condition
}
}
\description{
Comprehensive power analysis across multiple conditions using the new object-oriented
API. This function provides flexible power analysis by varying sample sizes, effect
sizes, interim analyses, and other parameters across a grid of conditions.
}
\details{
This modernized function uses the new object-oriented API and provides several advantages:

\strong{Unified Parameter Management:} All model and analysis specifications are contained
in the rctbayespower_design object, ensuring consistency and reducing parameter errors.

\strong{Flexible Condition Specification:} Conditions can vary any combination of sample sizes,
effect sizes, interim analyses, allocation ratios, and other parameters independently.

\strong{Full Parallelization:} All conditions are executed in parallel when n_cores > 1,
maximizing computational efficiency across the entire parameter grid.

\strong{Named Effect Sizes:} Effect sizes must be specified as named lists matching the
target_params from the design object, enabling multi-parameter analysis.

\strong{Extensible Design:} Easy to add new condition parameters (e.g., interim analyses)
without changing the function signature.
}
\examples{
\donttest{
# Create an ANCOVA model and design
ancova_model <- build_model_ancova_cont()
design <- build_design(
  build_model = ancova_model,
  target_params = "b_grouptreat",
  n_interim_analyses = 0,
  thresholds_success = 0.2,
  thresholds_futility = 0.0,
  p_sig_success = 0.975,
  p_sig_futility = 0.5
)

# Create conditions grid
conditions <- expand_conditions(
  sample_sizes = c(100, 200),
  effect_sizes_grid = list(
    list(b_grouptreat = 0.3),
    list(b_grouptreat = 0.5)
  ),
  n_interim_analyses = c(0, 1)
)

# Run power grid analysis
result <- power_grid_analysis(
  design = design,
  conditions = conditions,
  static_parameters = list(
    target_power_success = 0.8,
    target_power_futility = 0.9
  ),
  n_simulations = 100,  # Low for example
  n_cores = 1
)
}
}
